# Chapter 2. 운영체제 구조

## 2.1 운영체제 서비스

- **사용자 인터페이스**: UI는 `CLI`, `Batch파일`, `GUI` 등 다양한 형태로 제공
- **프로그램 실행**: 프로그램을 메모리에 적재하여 실행
- **입출력 연산**: 운영체제는 입출력 실행의 수단을 제공 (사용자가 직접 조작할 수 없음)
- **파일 시스템 조작**: 파일 생성, 수정, 삭제, 권한 등을 조작
- **통신**: 공유 메모리나 메시지 전달 등 프로세스간의 통신 구현
- **오류 탐지**: 항상 올바르고 일관성 있는 계산을 보장
- **자원 할당**: 다수의 작업들이 동시에 실행될 때, 그들 각각에 적절히 자원을 할당
- **회계**: 자원을 얼마나 사용했는지 기록하고 관리 (서비스 개선 등의 목적)
- **보호**: 시스템 자원에 대한 모든 접근이 통제되도록 보장
- **보안**: 부적절한 외부 접근 차단 및 침입 탐지

## 2.2 사용자 운영체제 인터페이스

- **CLI**: 사용자가 명령어를 직접 입력. (bash, csh, zsh …)
- **GUI**: 마우스 기반 윈도우 메뉴 시스템

## 2.3 시스템 호출

**API (Application Programming Interface)**

응용 프로그래머는 다음과 같은 이유로 API를 통해 간접적으로 시스템을 호출하며 프로그램을 구현:

- 프로그램 호환성
- 내부 구조를 몰라도 됨 (입력과 출력만 신경쓰면 됨)

## 2.4 시스템 호출의 유형

- **프로세스 제어**: 실행, 중지, wait, 메모리 할당 등
- **파일 조작**: 파일 생성, 삭제, 열기, 닫기, 읽기, 쓰기 등
- **장치 관리**: 장치 요구, 방출, 읽기, 쓰기 등
- **정보 유지**: 시간과 날짜, 시스템 데이터, 프로세스, 파일 ,장치 속성 획득 및 설정
- **통신**: 통신 연결, 생성, 제거, 송신, 수신 등
- **보호**: 여러가지 시스템 자원에 대한 접근 권한 설정

## 2.5 시스템 프로그램

시프로그램 개발과 실행을 위해 보다 편리한 환경을 제공하는 프로그램.

단순히 시스템 호출에 대한 사용자 인터페이스거나, 훨씬 복잡한 구조를 가질 수 있음.

시스템 프로그램의 종류

- **파일 관리**: 파일과 디렉토리 생성, 삭제, 복사, 덤프, 조작 등을 지원
- **상태 정보**: 시간과 날짜, 시스템 데이터, 프로세스, 파일 ,장치 속성 획득 및 설정을 지원
- **파일 변경**: 파일의 내용 생성, 변경 등을 위한 편집기 사용. 검색, 치환을 위한 특수 명령어 제공
- **프로그래밍언어 지원**: 일반적인 프로그래밍 언어에 대한 컴퍼일러, 어셈블러, 디버거 등을 운영체제와 함계 사용자에게 제공
- **프로그램 적재와 실행**: 프로그램을 메모리에 적재. 절대 로더, 재배치 가능 로더, 링키지 에디터, 중첩 로드등을 제공
- **통신**: 프로세스, 사용자, 컴퓨터 시스템들 사이의 가상 접속을 이루기 위한 기법 제공
- **백그라운드 서비스**: 부팅시 특정 시스템 프로그램을 시작시킬 수 있는 방법 제공. (서비스, 서브시스템, 데몬 등)

## 2.6 운영체제 설계 및 구현

**설계 목표 설정**

- 하드웨어와 시스템 타입 선택
- 사용자, 시스템 목적 확인

**기법과 정책 분리**

- 구현 세부사항(기법)과 정책을 분리 (”어떻게”와 “무엇”을 분리해야함)
    - ex) 타이머는 CPU를 보호하기 위한 **기법**이지만, 특정 사용자를 위해 타이머를 얼마나 오랫동안 설정할지는 **정책**의 결정에 따라 다름
- 정책은 변경의 소지가 있고, 기법과 정책을 분리하면 이를 유연하게 대체할 수 있음
    - ex) 정책이 변경되면 매개변수만 바꿔줘도 바로 새 정책을 적용할 수 있도록 구현(분리)

**구현**

- 대부분의 운영체제는 현재의 시스템 언어 혹은 고급 언어로 작성
- 이러한 특성은 운영체제의 구현, 유지 관리, 이식성을 향상

## 2.7 운영체제 구조

현대 운영체제와 같이 구모가 크고 복잡한 시스템은 신중하게 제작되어야 함.

**계층적 접근법**

운영체제를 여러개의 층으로 나누어 모듈화

- 장점
    - 구현과 디버깅이 간단함 (층마다 기능이 정해져 있음)
- 단점
    - 여러 층을 적절히 정의하기 어려움
    - 다른 유형의 구현 방법보다 효율성이 떨어짐

**마이크로커널**

커널로부터 중요하지 않은 구성요소를 제거하고, 시스템 및 사용자 수준 프로그램으로 재구현하여 운영체제를 구성하는 방법

- 장점
    - 확장이 용이함 (대부분의 서비스가 사용자 공간에 추가되기 때문)
    - 다른 하드웨어로 이식이 쉬움
    - 높은 보안과 신뢰성 (한 서비스가 잘못되더라도 시스템이 영향을 받지 않음)
- 단점
    - 가중된 시스템 기능 오버헤드 때문에 성능이 나빠짐

**모듈**

새로운 기능을 모듈 형태로 커널에 동적 링크

- 장점
    - 계층 구조 보다 유연하고, 마이크로 커널보다 효율적
    - 커널에 직접 구현하지 않아 수정사항에 대한 대처가 쉬움

**혼용 접근법**

하나의 구조만 채택하여 사용하지 않고, 위에 언급된 여러가지 구조를 혼용하여 사용. 

일반적으로 대부분의 OS가 이러한 접근 방법을 사용함.

## 2.8 운영체제 디버깅

**디버깅**: 하드웨어와 소프트웨어에서의 시스템의 오류를 발견하고 수정하는 행위

- 프로세스와 커널 장애의 디버깅은 로그 파일과 코어 덤프를 분석하는 방식으로 이루어짐
- 성능 문제또한 버그로 간주 될 수 있어, 이러한 병목 현상을 제거하는 성능 조정 또한 디버깅에 포함됨

## 2.9 운영체제 생성

재각각 고유한 환경을 가진 컴퓨터들에서 운영체제를 생성하기 위해서는 반드시 시스템 생성 작업을 실행해야 함.

시스템 생성을 위해서는 아래와 같은 종류의 정보들이 반드시 결정되어야 함.

- 무슨 CPU를 사용하는가?
- 부트 디스크는 어떻게 포맷될 것인가?
- 사용 가능한 메모리의 크기는 얼마인가?
- 어떠한 주변 장치가 사용 가능한가?
- 어떠한 운영체제의 옵션이 필요한지, 또한 어떤 매개변수 값이 사용되어야 한는가?

## 2.10 시스템 부트

커널을 적재하여 컴퓨터를 시동하는 절차를 시스템을 **부팅** 이랗고 함.

1. 미리 지정된 메모리 위치로부터 부트스트랩 프로그램을 찾아 실행
2. 장치에 대한 진단 작업 및 초기화 작업 수행, CPU 초기화 작업 수행
3. 부트스트랩은 직접 운영체제를 실행하거나, 펌웨어나 디스크에 저장되어 있는 프로그램을 차례대로 실행
4. 최종적으로 목표 운영체제가 메모리에 적재되고 실행될때까지 일련의 작업을 실행